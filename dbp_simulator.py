# -*- coding: utf-8 -*-
"""
/***************************************************************************
 dbpSimulator
                                 A QGIS plugin
 This plugin created for the IntoDBP project.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-12-20
        git sha              : $Format:%H$
        copyright            : (C) 2024 by KIOS Water Team
        email                : mkiria01@ucy.ac.cy
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import time
import csv
import pandas as pd
import platform
import subprocess

from epyt import epanet
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor, QFont
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QTimer
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QPushButton
from qgis.PyQt.QtWidgets import QDockWidget, QVBoxLayout, QWidget, QMessageBox, QTableWidgetItem
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QTextEdit, QPushButton
from qgis.core import (
    QgsGraduatedSymbolRenderer,
    QgsRendererRange,
    QgsSymbol,
    QgsStyle,
    QgsField, QgsVectorLayerSimpleLabeling, QgsTextFormat, QgsPalLayerSettings, QgsSettings
)
from shutil import copyfile

from qgis.core import QgsProject, QgsVectorLayer, QgsVectorLayerJoinInfo
from PyQt5.QtWidgets import QComboBox

# Import the code for the DockWidget
from .dbp_simulator_dockwidget import dbpSimulatorDockWidget
# Initialize Qt resources from file resources.py
from .resources import *

try:
    from epyt import epanet
except:
    subprocess.call(['pip', 'install','epyt==1.2.2', 'xlsxwriter>=3.2.0', 'openpyxl>=3.1.0'])
try:
    import numpy
except:
    subprocess.call(['pip', 'install', 'numpy==1.22.4'])

try:
    import openpyxl
except:
    subprocess.call(['pip', 'install', 'xlsxwriter>=3.2.0', 'openpyxl>=3.1.0'])


def get_desktop_path():
    desktop_path = os.path.join(os.path.join(os.path.expanduser('~')),'Desktop')
    if not os.path.exists(desktop_path):
        desktop_path = os.path.join(os.path.join(os.path.expanduser('~')),'Onedrive', 'Desktop')
    return desktop_path


class dbpSimulator:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.scenario_input_type_list = []
        self.node_id_list = []
        self.injection_rate_list = []
        self.species_list = []
        self.species_type_list = []
        self.initial_concentration_list = []
        self.chemical_parameter_list = []
        self.chemical_parameter_value_list = []
        self.demand_uncertainty_list = []
        self.msx_uncertainty_list = []
        self.results = None
        self.sensor_id = None
        self.results_excel_path = None
        self.scenario_chemparam = None
        self.scenario_initconce = None
        self.scenario_injection = None
        self.scenario_hydrparam = None
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'dbpSimulator_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&dbpSimulator')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'dbpRisk 2.0')
        self.toolbar.setObjectName(u'dbpRisk 2.0')

        #print "** INITIALIZING dbpSimulator"

        self.pluginIsActive = False
        self.dockwidget = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('dbpRisk 2.0', message)

    def add_action(self, icon_path, text, callback, enabled_flag=True, add_to_menu=True, add_to_toolbar=True,
                   status_tip=None, whats_this=None, parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = os.path.join(self.plugin_dir, 'icon.png')
        self.add_action(
            icon_path,
            text=self.tr(u'dbpRisk 2.0'),
            callback=self.run,
            parent=self.iface.mainWindow())

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING dbpSimulator"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD dbpSimulator"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&dbpRisk 2.0'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    def load_models(self):
        # Get selected model names from dropdowns
        self.network_model = self.dockwidget.network_models.currentText()
        self.reaction_model = self.dockwidget.reaction_models.currentText()

        # Check if selections are valid
        if not self.network_model or not self.reaction_model:
            self.show_message("Warning", "Please select network and reaction models.", button="OK",
                              icon="Warning")
            return

        # Build full file paths
        self.network_model = os.path.join(self.plugin_dir, "data", "network_models", self.network_model)
        self.reaction_model = os.path.join(self.plugin_dir, "data", "reaction_models", self.reaction_model)

        # Get model prefix from the selected network model file
        self.model_prefix = os.path.splitext(os.path.basename(self.network_model))[0]
        # print(self.model_prefix)

        # Check if files exist
        if not os.path.exists(self.network_model):
            self.show_message("Warning", f"Network model not found:\n{self.network_model}.", button="OK", icon="Warning")
            return

        if not os.path.exists(self.reaction_model):
            self.show_message("Warning", f"Reaction model not found:\n{self.reaction_model}.", button="OK", icon="Warning")
            return

        project_path = os.path.join(self.plugin_dir, "data", "project_data", f'dbpRisk_2_0_{self.model_prefix}.qgz')
        project_path_tmp = os.path.join(self.plugin_dir, "data", "tmp_data", f'dbpRisk_2_0_{self.model_prefix}.qgz')
        copyfile(project_path, project_path_tmp)
        project = QgsProject.instance()
        project.read(project_path_tmp)

        # Load EPANET network model and MSX reaction model
        self.G = epanet(self.network_model)
        self.G.loadMSXFile(self.reaction_model)

        # Read default parameter values from MSX file
        self.parameter_defaults = {}  # Dictionary: param_name -> value

        # ToDo: need to change to self.parameter_defaults[param_name] = self.G.getMSXParametersTanksValue()
        with open(self.reaction_model, 'r') as msx_file:
            lines = msx_file.readlines()
            in_coeff_section = False
            for line in lines:
                line = line.strip()
                if line.startswith("[COEFFICIENTS]"):
                    in_coeff_section = True
                    continue
                if line.startswith("[") and in_coeff_section:
                    break  # Exit when we reach next section

                if in_coeff_section and line.startswith("PARAMETER"):
                    parts = line.split()
                    if len(parts) == 3:
                        _, param_name, param_value = parts
                        try:
                            self.parameter_defaults[param_name] = float(param_value)
                        except ValueError:
                            continue  # Skip invalid lines

        msx_species = self.G.getMSXSpeciesNameID()
        msx_parameters = self.G.getMSXParametersNameID()

        self.dockwidget.model_species_injection.clear()
        self.dockwidget.model_species_initial_conc.clear()
        self.dockwidget.select_species.clear()
        self.dockwidget.sim_multi_model_species.clear()
        # self.dockwidget.sim_multi_model_species_2.clear()
        self.dockwidget.chemical_parameters.clear()

        self.dockwidget.model_species_injection.addItems(msx_species)
        self.dockwidget.model_species_initial_conc.addItems(msx_species)

        self.dockwidget.select_species.addItems(msx_species)
        self.dockwidget.sim_multi_model_species.addItems(msx_species)
        # self.dockwidget.sim_multi_model_species_2.addItems(msx_species)
        self.dockwidget.chemical_parameters.addItems(msx_parameters)

        try:
            try:
                self.junctions_layer = QgsProject.instance().mapLayersByName(f'{self.model_prefix}_junctions')[0]
                self.reservoirs_layer = QgsProject.instance().mapLayersByName(f'{self.model_prefix}_reservoirs')[0]
                self.tanks_layer = QgsProject.instance().mapLayersByName(f'{self.model_prefix}_tanks')[0]
                self.iface.setActiveLayer(self.junctions_layer)
            except:
                pass
        finally:
            message = f'Models loaded successfully!'
            level = 3  # Qgis.Success
            self.iface.messageBar().pushMessage("dbpRisk 2.0", message, level, duration=4)

            # Enable selection
            self.iface.actionSelect().trigger()

        self.dockwidget.loadexcel.setEnabled(True)
        self.dockwidget.insert_action.setEnabled(True)
        self.dockwidget.scenario_table.setEnabled(True)
        self.dockwidget.import_scenario.setEnabled(True)
        self.dockwidget.export_scenario.setEnabled(True)
        self.dockwidget.data_manager.setEnabled(True)
        self.dockwidget.import_node_injection.setEnabled(True)

    def import_excel_file(self, lbl_browse):
        # Set initial directory to "ts_data" folder
        default_dir = os.path.join(self.plugin_dir, "data", "ts_data")
        options = QFileDialog.Options()

        fileName, _ = QFileDialog.getOpenFileName(
            None,
            "Select Excel File",
            default_dir,  # Start browsing here
            "Excel Files (*.xls *.xlsx)",
            options=options
        )

        self.imported_excel_file = fileName

        if fileName:
            lbl_browse.setText(fileName)

    def on_node_button_clicked(self, widget):
        # After the feature is selected, get the feature's ID
        if self.junctions_layer.selectedFeatures():
            feature_id = self.junctions_layer.selectedFeatures()[0]['id']
            widget.setText(str(feature_id))  # Update the Node ID input field
        if self.reservoirs_layer.selectedFeatures():
            feature_id = self.reservoirs_layer.selectedFeatures()[0]['id']
            widget.setText(str(feature_id))  # Update the Node ID input field
        if self.tanks_layer.selectedFeatures():
            feature_id = self.tanks_layer.selectedFeatures()[0]['id']
            widget.setText(str(feature_id))  # Update the Node ID input field

    # def scenario_delete_accept(self, selected_item):
    def scenario_delete_accept(self, row):
        # Get the row of the selected item
        selected_item = self.dockwidget.scenario_table.selectedItems()
        if selected_item:
            selected_row = selected_item[0].row()

            # Remove the selected row from the QTableWidget
            self.dockwidget.scenario_table.removeRow(selected_row)

            try:
                self.scenario_input_type_list.pop(selected_row)
                self.node_id_list.pop(selected_row)
                self.injection_rate_list.pop(selected_row)
                self.species_list.pop(selected_row)
                self.species_type_list.pop(selected_row)
                self.initial_concentration_list.pop(selected_row)
                self.chemical_parameter_list.pop(selected_row)
                self.chemical_parameter_value_list.pop(selected_row)
                self.demand_uncertainty_list.pop(selected_row)
                self.msx_uncertainty_list.pop(selected_row)

            except IndexError:
                print(f"Error: Tried to delete row {selected_row}, but one or more lists are out of sync.")

        self.update_scenario_buttons()

        # del row

    def scenario_delete(self):
        selected_item = self.dockwidget.scenario_table.currentItem()
        # Get the currently selected row
        selected_row = self.dockwidget.scenario_table.currentRow()
        if selected_item:
            self.showYesNoMessage(
                "dbpRisk 2.0", f"Action {selected_row + 1} is going to be deleted?",
                # lambda: self.scenario_delete_accept(selected_item),
                lambda: self.scenario_delete_accept(selected_row),
                lambda: None, "Warning")
        else:
            self.show_message(
                "dbpRisk 2.0", f"Please select an action below to delete.", "OK", "Warning")
    # # Add the scenario string to QTableWidget
    # def add_scenario_to_table(self, scenario):
    #     # Split the scenario string into individual key-value pairs
    #     scenario_values = [value.strip() for value in scenario.split(',')]
    #
    #     # Ensure the table has enough columns
    #     if len(scenario_values) > self.dockwidget.scenario_table.columnCount():
    #         self.dockwidget.scenario_table.setColumnCount(len(scenario_values))
    #
    #     # Add a new row to the QTableWidget
    #     row_position = self.dockwidget.scenario_table.rowCount()
    #     self.dockwidget.scenario_table.insertRow(row_position)
    #
    #     # Populate each cell with the full key-value pair
    #     for col, value in enumerate(scenario_values):
    #         self.dockwidget.scenario_table.setItem(row_position, col, QTableWidgetItem(value))

    # Add the scenario string to a single column in the QTableWidget
    # def add_scenario_to_table(self, scenario):
    #     """
    #     Adds the entire scenario as a single entry in one column of the QTableWidget.
    #     """
    #     # Add a new row to the QTableWidget
    #     row_position = self.dockwidget.scenario_table.rowCount()
    #     self.dockwidget.scenario_table.insertRow(row_position)
    #
    #     # Insert the entire scenario string into the first column of the new row
    #     self.dockwidget.scenario_table.setColumnCount(1)  # Ensure only one column exists
    #     self.dockwidget.scenario_table.setItem(row_position, 0, QTableWidgetItem(scenario))

    def add_scenario_to_table(self, scenario):
        """
        Adds the entire scenario as a single entry in one column of the QTableWidget.
        Sets the row background color based on the source of the scenario.
        """
        # Determine the background color based on the active radio button
        # if self.dockwidget.radio_injection.isChecked():
        #     background_color = QColor(255, 255, 153)  # Light yellow
        # elif self.dockwidget.radio_initconce.isChecked():
        #     background_color = QColor(255, 204, 204)  # Light red
        # elif self.dockwidget.radio_chemparameters.isChecked():
        #     background_color = QColor(153, 255, 153)  # Light green
        # else:
        #     background_color = QColor(255, 255, 255)  # Default white

        # Add a new row to the QTableWidget
        row_position = self.dockwidget.scenario_table.rowCount()
        self.dockwidget.scenario_table.insertRow(row_position)

        # Insert the entire scenario string into the first column of the new row
        self.dockwidget.scenario_table.setColumnCount(1)  # Ensure only one column exists
        item = QTableWidgetItem(scenario)
        # item.setBackground(background_color)  # Set the background color
        self.dockwidget.scenario_table.setItem(row_position, 0, item)

        self.update_scenario_buttons()

    # def add_scenario_to_table(self, scenario):
    #     """
    #     Adds the entire scenario as a single entry in one column of the QTableWidget.
    #     Sets the row background color based on the source of the scenario and prevents color change on selection.
    #     """
    #     # Determine the background color based on the active radio button
    #     # if self.dockwidget.radio_injection.isChecked():
    #     #     background_color = QColor(255, 204, 204)  # Light red
    #     # elif self.dockwidget.radio_initconce.isChecked():
    #     #     background_color = QColor(153, 255, 153)  # Light green
    #     # elif self.dockwidget.radio_chemparameters.isChecked():
    #     #     background_color = QColor(153, 204, 255)  # Light blue
    #     # else:
    #     #     background_color = QColor(255, 255, 255)  # Default white
    #
    #     if self.dockwidget.radio_injection.isChecked():
    #         text_color = QColor(255, 0, 0)  # Red
    #     elif self.dockwidget.radio_initconce.isChecked():
    #         text_color = QColor(0, 102, 0)  # Green
    #     elif self.dockwidget.radio_chemparameters.isChecked():
    #         text_color = QColor(0, 0, 255)  # Blue
    #     else:
    #         text_color = QColor(0, 0, 0)  # Default black
    #
    #     # Add a new row to the QTableWidget
    #     row_position = self.dockwidget.scenario_table.rowCount()
    #     self.dockwidget.scenario_table.insertRow(row_position)
    #
    #     # Insert the entire scenario string into the first column of the new row
    #     self.dockwidget.scenario_table.setColumnCount(1)  # Ensure only one column exists
    #     item = QTableWidgetItem(scenario)
    #
    #     # Set the background color and ensure it doesn't change on selection
    #     # item.setBackground(background_color)
    #     # Set the text color explicitly
    #     item.setForeground(text_color)
    #
    #     self.dockwidget.scenario_table.setItem(row_position, 0, item)

    def clear_scenario_table(self):
        self.showYesNoMessage(
            "dbpRisk 2.0",
            "Are you sure you want to clear all actions?",
            lambda: self.clear_scenario_table_accept(),  # Pass the action as a lambda
            lambda: None,  # Do nothing if the user cancels
            "Warning"
        )

    def clear_scenario_table_accept(self):
        # Remove all rows and columns from the QTableWidget
        self.dockwidget.scenario_table.setRowCount(0)
        self.dockwidget.scenario_table.setColumnCount(0)

        # Clear previous entries
        self.scenario_input_type_list.clear()
        self.node_id_list.clear()
        self.injection_rate_list.clear()
        self.species_list.clear()
        self.species_type_list.clear()
        self.initial_concentration_list.clear()
        self.chemical_parameter_list.clear()
        self.chemical_parameter_value_list.clear()
        self.demand_uncertainty_list.clear()
        self.msx_uncertainty_list.clear()

        self.update_scenario_buttons()

    def save_scenarios_to_csv(self):
        """
        Saves all scenarios from the QTableWidget to a CSV file.
        """
        # Set default folder to scenarios_data directory
        default_dir = os.path.join(self.plugin_dir, "data", "scenarios_data")
        options = QFileDialog.Options()

        file_path, _ = QFileDialog.getSaveFileName(
            self.dockwidget,
            "Save Scenarios",
            default_dir,
            "CSV Files (*.csv);;All Files (*)",
            options=options
        )

        # If the user selects a file, proceed with saving
        if file_path:
            try:
                # Open the CSV file for writing
                with open(file_path, mode='w', newline='', encoding='utf-8') as file:
                    writer = csv.writer(file)

                    # Loop through all the rows and columns of the QTableWidget
                    for row in range(self.dockwidget.scenario_table.rowCount()):
                        row_data = []
                        for col in range(self.dockwidget.scenario_table.columnCount()):
                            item = self.dockwidget.scenario_table.item(row, col)
                            if item is not None:
                                row_data.append(item.text())  # Append the cell text
                            else:
                                row_data.append("")  # In case the cell is empty

                        # Write the row to the CSV file
                        writer.writerow(row_data)

                # Display success message after saving
                self.show_message("Success", "Scenario successfully saved to CSV.", button="OK",
                                  icon='Info')

            except Exception as e:
                # Handle any errors (e.g., file write errors)
                print(f"Error saving CSV: {e}")
                self.show_message("Error", "An error occurred while saving the scenario.", button="OK",
                                  icon='Warning')

    def show_message(self, title, msg, button, icon):
        msgBox = QMessageBox()
        if icon == 'Warning':
            msgBox.setIcon(QMessageBox.Warning)
        if icon == 'Info':
            msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle(title)
        msgBox.setText(msg)
        msgBox.setStandardButtons(QMessageBox.Ok)
        font = QFont()
        font.setPointSize(9)
        msgBox.setFont(font)
        msgBox.setWindowFlags(Qt.CustomizeWindowHint | Qt.WindowStaysOnTopHint | Qt.WindowCloseButtonHint)
        buttonY = msgBox.button(QMessageBox.Ok)
        buttonY.setText(button)
        buttonY.setFont(font)
        msgBox.exec_()

    def load_scenarios_from_csv(self):
        """
        Loads scenarios from a CSV file into the QTableWidget.
        """
        # Set default folder to scenarios_data directory
        default_dir = os.path.join(self.plugin_dir, "data", "scenarios_data")
        options = QFileDialog.Options()

        file_path, _ = QFileDialog.getOpenFileName(
            self.dockwidget,
            "Open Scenarios CSV",
            default_dir,
            "CSV Files (*.csv);;All Files (*)",
            options=options
        )

        # If the user selects a file, proceed with loading
        if file_path:
            try:
                # Open the CSV file for reading
                with open(file_path, mode='r', newline='', encoding='utf-8') as file:
                    reader = csv.reader(file)

                    # Clear the table before loading new data
                    self.dockwidget.scenario_table.setRowCount(0)  # Clear existing rows
                    self.dockwidget.scenario_table.setColumnCount(0)  # Clear existing columns

                    # Read the rows from the CSV and add them to the QTableWidget
                    for row_data in reader:
                        if row_data:  # Ensure the row isn't empty
                            # Remove any trailing empty cells
                            row_data = [data for data in row_data if data.strip()]

                            # Skip empty rows after cleaning
                            if not row_data:
                                continue

                            row_position = self.dockwidget.scenario_table.rowCount()  # Get the current row count
                            self.dockwidget.scenario_table.insertRow(row_position)  # Insert a new row at the end

                            # If the row is longer than the current column count, adjust column count
                            if len(row_data) > self.dockwidget.scenario_table.columnCount():
                                self.dockwidget.scenario_table.setColumnCount(len(row_data))

                            # Populate each cell with the value from the CSV
                            for col, value in enumerate(row_data):
                                # Ensure there is a valid item at the cell and populate it
                                item = QTableWidgetItem(value)  # Create a table item with the value
                                self.dockwidget.scenario_table.setItem(row_position, col,
                                                                       item)  # Set the item at the correct cell

                # Display success message after loading
                self.show_message("Success", "Scenario successfully loaded from CSV", button="OK",
                                  icon='Info')

            except Exception as e:
                # Handle any errors (e.g., file read errors)
                print(f"Error loading CSV: {e}")
                self.show_message("Error", "An error occurred while loading the scenario", button="OK",
                                  icon='Warning')

        # Populate internal scenario lists
        # Clear previous entries
        self.scenario_input_type_list.clear()
        self.node_id_list.clear()
        self.injection_rate_list.clear()
        self.species_list.clear()
        self.species_type_list.clear()
        self.initial_concentration_list.clear()
        self.chemical_parameter_list.clear()
        self.chemical_parameter_value_list.clear()
        self.demand_uncertainty_list.clear()
        self.msx_uncertainty_list.clear()

        # Parse each row and update lists
        row_count = self.dockwidget.scenario_table.rowCount()
        for row in range(row_count):
            item_text = self.dockwidget.scenario_table.item(row, 0).text()

            # Default values
            input_type = None
            node_id = None
            species = None
            injection_type = None
            injection_rate = None
            initial_conc = None
            chemical_param = None
            chemical_value = None
            demand_uncertainty = None
            msx_uncertainty = None

            if "Injection Rate" in item_text:
                input_type = 1
                try:
                    node_id = item_text.split("NodeID:")[1].split(",")[0].strip()
                    species = item_text.split("Species:")[1].split(",")[0].strip()
                    injection_type = item_text.split("Type:")[1].split(",")[0].strip()
                    injection_rate = float(item_text.split("Injection Rate:")[1].split(",")[0].strip())
                    msx_uncertainty = float(item_text.split("Uncertainty (%):")[1].strip())
                except Exception:
                    continue

            elif "Initial Concentration" in item_text:
                input_type = 2
                try:
                    node_id = item_text.split("NodeID:")[1].split(",")[0].strip()
                    species = item_text.split("Species:")[1].split(",")[0].strip()
                    initial_conc = float(item_text.split("Initial Concentration:")[1].split(",")[0].strip())
                    msx_uncertainty = float(item_text.split("Uncertainty (%):")[1].strip())
                except Exception:
                    continue

            elif "Chemical Parameter" in item_text:
                input_type = 3
                try:
                    chemical_param = item_text.split("Chemical Parameter:")[1].split(",")[0].strip()
                    chemical_value = float(item_text.split("Value:")[1].split(",")[0].strip())
                    msx_uncertainty = float(item_text.split("Uncertainty (%):")[1].strip())
                except Exception:
                    continue

            elif "Demands Uncertainty" in item_text:
                input_type = 4
                try:
                    demand_uncertainty = float(item_text.split("Demands Uncertainty (%):")[1].strip())
                except Exception:
                    continue

            # Append to internal lists
            self.scenario_input_type_list.append(input_type)
            self.node_id_list.append(node_id)
            self.injection_rate_list.append(injection_rate)
            self.species_list.append(species)
            self.species_type_list.append(injection_type)
            self.initial_concentration_list.append(initial_conc)
            self.chemical_parameter_list.append(chemical_param)
            self.chemical_parameter_value_list.append(chemical_value)
            self.demand_uncertainty_list.append(demand_uncertainty)
            self.msx_uncertainty_list.append(msx_uncertainty)

        self.update_scenario_buttons()


    def update_scenario_list(self):
        # self.scenario_injection = self.dockwidget.radio_injection.isChecked()
        # self.scenario_initconce = self.dockwidget.radio_initconce.isChecked()
        # self.scenario_chemparam = self.dockwidget.radio_chemparameters.isChecked()
        # self.scenario_hydrparam = self.dockwidget.radio_hydrparameters.isChecked()

        self.scenario_input_type = self.dockwidget.scenarios_tabs.currentIndex() + 1

        # Initialize
        self.nodeID = None
        self.species = None
        self.injection_type = None
        self.injection_rate = None
        self.msx_uncertainty = None
        self.initial_concentration = None
        self.msx_uncertainty = None
        self.chemical_parameter = None
        self.parameter_value = None
        self.hydrparam_uncertainty = None

        # Action types
        if self.scenario_input_type == 1:
        # if self.dockwidget.scenarios_tabs.currentIndex() == 0:
            self.nodeID = self.dockwidget.node_selected_injection.text()

            if not self.nodeID.strip():
                self.show_message("Warning", "Please select a node from map.", button="OK", icon="Warning")
                return

            self.species = self.dockwidget.model_species_injection.currentText()
            self.injection_type = self.dockwidget.injection_types.currentText()
            # msx_types = {"Inflow Concentration": 'CONCEN', "Mass Booster": 'MASS',
                         # "Set Point Booster": 'SETPOINT', "Flow Paced Booster": 'FLOWPACED'}
            self.injection_rate = self.dockwidget.injection_rate.value()
            self.msx_uncertainty = self.dockwidget.uncertainty_injection.value()
            scenario = (f'NodeID: {self.nodeID}, '
                        f'Species: {self.species}, '
                        f'Type: {self.injection_type}, '
                        f'Injection Rate: {self.injection_rate}, '
                        f'Uncertainty (%): {self.msx_uncertainty}')

        elif self.scenario_input_type == 2:
        # elif self.dockwidget.scenarios_tabs.currentIndex() == 1:
            self.nodeID = self.dockwidget.node_selected_initial_conc.text()

            if not self.nodeID.strip():
                self.show_message("Warning", "Please select node from map.", button="OK", icon="Warning")
                return

            self.species = self.dockwidget.model_species_initial_conc.currentText()
            self.initial_concentration = self.dockwidget.initial_concentration.value()
            self.msx_uncertainty = self.dockwidget.uncertainty_initial_conc.value()

            scenario = (f'NodeID: {self.nodeID}, '
                        f'Species: {self.species}, '
                        f'Initial Concentration: {self.initial_concentration}, '
                        f'Uncertainty (%): {self.msx_uncertainty}')

        elif self.scenario_input_type == 3:
        # elif self.dockwidget.scenarios_tabs.currentIndex() == 2:
            self.chemical_parameter = self.dockwidget.chemical_parameters.currentText()
            self.parameter_value = self.dockwidget.chem_parameter_value.value()
            self.msx_uncertainty = self.dockwidget.uncertainty_chem_parameter.value()

            scenario = (f'Chemical Parameter: {self.chemical_parameter}, '
                        f'Value: {self.parameter_value}, '   
                        f'Uncertainty (%): {self.msx_uncertainty}')

        elif self.scenario_input_type == 4:
            self.show_message("Notice", "Demands Uncertainty is currently disabled", button="OK", icon="Info")
            return

        # elif self.dockwidget.scenarios_tabs.currentIndex() == 3:
        #     self.hydrparam_uncertainty = self.dockwidget.uncertainty_hydr_parameter.value()
        #
        #     scenario = f'Demands Uncertainty (%): {self.hydrparam_uncertainty}'

        # self.dockwidget.scenario_table.addItem(scenario)
        self.add_scenario_to_table(scenario)

        # Input parameters
        self.scenario_input_type_list.append(self.scenario_input_type)
        self.node_id_list.append(self.nodeID)
        self.injection_rate_list.append(self.injection_rate)
        self.species_list.append(self.species)
        self.species_type_list.append(self.injection_type)
        self.initial_concentration_list.append(self.initial_concentration)
        self.chemical_parameter_list.append(self.chemical_parameter)
        self.chemical_parameter_value_list.append(self.parameter_value)
        self.demand_uncertainty_list.append(self.hydrparam_uncertainty)
        self.msx_uncertainty_list.append(self.msx_uncertainty)

        self.update_scenario_buttons()

    def apply_graduated_symbology(self, column_name):
        """
        Apply graduated symbology to self.junctions_layer based on the specified column index.

        :param column_index: The index of the column to use for symbology.
        """
        # Check if the field exists in the layer
        if not self.junctions_layer.fields().indexOf(column_name) >= 0:
            raise ValueError(f"Field '{column_name}' does not exist in the layer.")

        # Create symbol ranges
        ranges = []

        # Define the ranges for graduated symbology
        # Example: Three ranges for demonstration purposes
        if 'CL2' in column_name or 'C_SRA' in column_name or 'C_FRA' in column_name:
            range_definitions = [
                # Updated colors based on the request
                (0, 0.02, "0-0.02", "#003f5c"),  # Blue for lower levels
                (0.02, 0.05, "0.02 - 0.05", "#2f95d9"),  # Cyan for intermediate low levels
                (0.05, 0.1, "0.05 - 0.1", "#81d450"),  # Light green for medium levels
                (0.1, 0.2, "0.1 - 0.2", "#f7a728"),  # Orange for higher levels
                (0.2, 0.3, "0.2 - 0.3", "#ff3333"),  # Even darker red for high levels
                (0.3, float('inf'), "Above 0.3", "#d7191c"),  # Deep red for highest levels
            ]
        elif 'THMs' in column_name:
            range_definitions = [
                # For THMs (Trihalomethanes)
                (0, 5.5, "0-5.5", "#003f5c"),  # Blue for lower levels
                (5.5, 11, "5.5-11", "#2f95d9"),  # Cyan for intermediate low levels
                (11, 16.5, "11-16.5", "#81d450"),  # Light green for medium levels
                (16.5, 22, "16.5-22", "#f7a728"),  # Orange for higher levels
                (22, float('inf'), "Above 22", "#d7191c"),  # Red for highest levels
                ]
        else:
            range_definitions = [
                # For HAAs (Haloacetic Acids)
                (0, 1, "0-1", "#003f5c"),  # Blue for lower levels
                (1, 2, "1-2", "#2f95d9"),  # Cyan for intermediate low levels
                (2, 3, "2-3", "#81d450"),  # Light green for medium levels
                (3, 4, "3-4", "#f7a728"),  # Orange for higher levels
                (4, float('inf'), "Above 4", "#d7191c"),  # Red for highest l
            ]

        for min_value, max_value, label, color in range_definitions:
            symbol = QgsSymbol.defaultSymbol(self.junctions_layer.geometryType())
            symbol.setColor(QColor(color))
            range = QgsRendererRange(min_value, max_value, symbol, label)
            ranges.append(range)

        # Create the renderer
        renderer = QgsGraduatedSymbolRenderer(column_name, ranges)

        # Set the mode to equal interval (can be changed to other modes if needed)
        renderer.setMode(QgsGraduatedSymbolRenderer.EqualInterval)

        # Apply the renderer to the layer
        self.junctions_layer.setRenderer(renderer)

        # Refresh the layer to update the rendering
        self.junctions_layer.triggerRepaint()

    def apply_join(self, target_layer, join_layer, join_field, target_field):
        # Check if the target layer already has the join applied
        existing_joins = target_layer.vectorJoins()
        for join in existing_joins:
            if join.joinLayerId() == join_layer.id():
                # If join exists, remove it
                target_layer.removeJoin(join.joinLayerId())

        # Create new join information
        join_info = QgsVectorLayerJoinInfo()
        join_info.setJoinLayerId(join_layer.id())
        join_info.setJoinLayer(join_layer)
        join_info.setJoinFieldName(join_field)
        join_info.setTargetFieldName(target_field)
        join_info.setUsingMemoryCache(True)

        # Reapply the join
        if target_layer.addJoin(join_info):
            pass
            # print("Join reapplied successfully.")

        # target_layer.reload()
        target_layer.triggerRepaint()
        self.iface.mapCanvas().refresh()

    def load_excel_layer(self, sheet_name, excel_file):
        layer_path = f"{excel_file}|layername={sheet_name}"
        layer = QgsVectorLayer(layer_path, sheet_name, "ogr")
        if not layer.isValid():
            raise ValueError(f"Failed to load layer: {sheet_name}")
        return layer

    def show_update_map_call(self):
        mode = self.dockwidget.hour_min_max.currentText().lower()  # 'hour', 'min', 'max', 'mean'
        species = self.dockwidget.select_species.currentText()

        # Min
        if mode == "min":
            column_name = f'{species}_stats_Min'

        # Max
        if mode == "max":
            column_name = f'{species}_stats_Max'

        # Mean
        if mode == "mean":
            column_name = f'{species}_stats_Mean'

        if mode in ['min', 'max', 'mean']:
            sheet_layer = self.load_excel_layer(species + '_stats', excel_file=self.summary_output_path)

            if not QgsProject.instance().mapLayersByName(sheet_layer.name()):
                QgsProject.instance().addMapLayer(sheet_layer, False)

            self.apply_join(self.junctions_layer, sheet_layer, 'NodeID', "id")
            self.apply_graduated_symbology(column_name)

        # Hour
        if mode == "hour":
            # Load hourly sheet and field
            hour = int(self.dockwidget.sim_hour.currentText())
            column_index = 12 * hour + 3
            column_name = f'{species}_Field{column_index}'

            sheet_layer = self.load_excel_layer(species, excel_file=self.results_excel_path)
            if not QgsProject.instance().mapLayersByName(sheet_layer.name()):
                QgsProject.instance().addMapLayer(sheet_layer, False)

            self.apply_join(self.junctions_layer, sheet_layer, 'Field2', "id")
            self.apply_graduated_symbology(column_name)

        self.junctions_layer.setDisplayExpression(column_name)

        # Define your HTML map tip
        html_tip = f"""
        <table style="font-size:12px;">
        <tr><td><b>{species}:</b></td><td>[% format_number("{column_name}", 5) %]</td></tr>
        </table>
        """
        # Set the HTML map tip
        self.junctions_layer.setMapTipTemplate(html_tip)
        # Refresh the layer and map canvas
        self.junctions_layer.triggerRepaint()

        QgsSettings().setValue("/MapTips/MapTipsEnabled", True)

        # Show success message
        self.iface.messageBar().clearWidgets()
        self.iface.messageBar().pushMessage("dbpRisk 2.0", "Map updated!", level=3, duration=4)
        self.dockwidget.results_group.setEnabled(True)

    def showError(self):
        try:
            self.timer_watch.stop()
        except:
            pass
        self.iface.messageBar().clearWidgets()

        try:
            os.system(f'taskkill /f /im {self.app}')
            self.iface.messageBar().pushMessage("dbpRisk 2.0", "Successfully terminated.",
                                                level=0, duration=2)
        except:
            self.iface.messageBar().pushMessage("dbpRisk 2.0", "Error Encountered while running "
                                                                                  "script.", level=1, duration=2)

    def run_message(self):
        # Check if Excel path is empty
        if not self.dockwidget.excel_path.text().strip():
            self.show_message("Warning", "Please select data source.", button="OK",
                              icon="Warning")
            return
        
        # Show message - Running...
        widget = self.iface.messageBar().createMessage('dbpRisk 2.0', "Simulating...")
        button = QPushButton(widget)
        button.setText("Stop")
        button.pressed.connect(self.showError)
        widget.layout().addWidget(button)
        self.iface.messageBar().pushWidget(widget, 0)
        QTimer.singleShot(100, self.run_app)  # Delay of 100 ms

        self.update_plot_buttons()

    def run_app(self):
        # Run dbpScenarioGenerator app
        from .app.dbpScenarioGenerator import WaterQualitySimulation
        # TODO: replace mat files with df
        # df = pd.read_excel(self.dockwidget.excel_path.text())
        self.sensor_id = ['dist412', 'dist1268', 'T_Zone', 'WTP']

        self.df = pd.read_excel(self.imported_excel_file)

        input_parameters = {
            "inpname": self.network_model,  # input name epanet
            "msxname": self.reaction_model,  # msx file
            "excel_file": self.df,  # excel file
            "t_d": 1,  # simulation days
            "msx_timestep": 300,  # timestep in seconds 300 = 5 minutes
            "scenario_id": self.dockwidget.scenario_table.rowCount(),  # total number of actions
            "Input_Type": self.scenario_input_type_list,  # list of the scenario type
            "sensor_id": self.node_id_list,  # list of the nodes ids
            "injection_rate": self.injection_rate_list,  # list of the injection rates
            "species_names": self.species_list,  # list of the species names
            "species_types": self.species_type_list,  # list of the species types
            "initial_concentration": self.initial_concentration_list,  # list of the initial concentrations
            "chemical_param": self.chemical_parameter_list,  # list of the chemical parameters
            "chemical_value": self.chemical_parameter_value_list,  # list of the chemical parameters values
            "Demand_Uncertainty": 0,  # list of the demand uncertainties
            # "Demand_Uncertainty": self.demand_uncertainty_list,  # list of the demand uncertainties
            "MSX_uncertainty": 0  # list of the msx uncertainties
            # "MSX_uncertainty": self.msx_uncertainty_list  # list of the msx uncertainties
        }

        # print("Network Model:", self.network_model)
        # print("Reaction Model:", self.reaction_model)
        # print("Excel DataFrame:", self.df)
        # print("Scenario Table Row Count:", self.dockwidget.scenario_table.rowCount())
        # print("Scenario Input Type List:", self.scenario_input_type_list)
        # print("Node ID List:", self.node_id_list)
        # print("Injection Rate List:", self.injection_rate_list)
        # print("Species List:", self.species_list)
        # print("Species Type List:", self.species_type_list)
        # print("Initial Concentration List:", self.initial_concentration_list)
        # print("Chemical Parameter List:", self.chemical_parameter_list)
        # print("Chemical Parameter Value List:", self.chemical_parameter_value_list)
        # print("Demand Uncertainty List:", self.demand_uncertainty_list)
        # print("MSX Uncertainty List:", self.msx_uncertainty_list)

        self.sim = WaterQualitySimulation(**input_parameters)
        self.sim.setup_simulation()
        try:
            [self.results, self.node_id, self.species_names_function] = self.sim.run_simulation()
            self.results_excel_path = os.path.join(self.plugin_dir, "data", "tmp_data", "tmp_results.xlsx")
            self.sim.export_to_excel(self.results, self.results_excel_path)
            # self.dockwidget.plot_species_nodes.setEnabled(True)

            self.summary_output_path = os.path.join(self.plugin_dir, "data", "tmp_data", "min_max_mean.xlsx")
            self.exportMSXstatistics(self.results_excel_path, self.summary_output_path, nodeids=True, nodeindex=False)

        finally:
            self.iface.messageBar().clearWidgets()
            message = f'Run successfully!'
            level = 3  # Qgis.Success
            self.iface.messageBar().pushMessage("dbpRisk 2.0", message, level, duration=4)
            self.dockwidget.results_group.setEnabled(True)

    def plot_sensorlocations(self):
        mes = self.sim.Measured_Chlorine()
        sensor_id = ['dist412', 'dist1268', 'T_Zone', 'WTP']
        sensor_index = []
        for sen_id in sensor_id:
            sensor_index.append(self.node_id.index(sen_id)+1)
        sensor_description = ['DMA_DP3', 'DMA_inlet', 'Tank_outlet', 'DWTP_outlet']
        # selected_species = self.dockwidget.sim_multi_model_species_2.checkedItems()
        selected_species = self.dockwidget.sim_multi_model_species.checkedItems()
        if selected_species:
            species_index = []
            for sen_id in selected_species:
                species_index.append(self.species_names_function.index(sen_id) + 1)
            canvas = self.sim.plot_data(mes, [self.results], sensor_index, species_index, selected_species, sensor_description, f"")
            self.create_dock_widget_with_plot(canvas)

    def create_dock_widget_with_plot(self, canvas):
        """
        Creates a dock widget in QGIS with a matplotlib plot embedded.
        :param canvas: Matplotlib canvas to embed in the dock widget
        """
        # Create the dock widget
        dock_name = "dbpRisk 2.0: Plots"
        try:
            self.dock_plots.close()
        except:
            pass

        self.dock_plots = QDockWidget(dock_name, self.iface.mainWindow())
        self.dock_plots.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)

        # Create a QWidget for the dock contents
        dock_widget = QWidget()
        self.dock_plots.setWidget(dock_widget)

        # Set up the layout
        layout = QVBoxLayout()
        dock_widget.setLayout(layout)
        dock_widget.setMinimumHeight(400)
        dock_widget.setMinimumWidth(500)
        canvas.figure.subplots_adjust(left=0.15, bottom=0.05)
        # Add the matplotlib canvas to the layout
        layout.addWidget(canvas)

        # Find the layers panel widget
        self.layers_panel = self.iface.mainWindow().findChild(QDockWidget, "Layers")

        # Add the dock widget to QGIS above the layers panel
        self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dock_plots)
        self.iface.mainWindow().tabifyDockWidget(self.layers_panel, self.dock_plots)

        # Ensure the dock widget is displayed
        self.dock_plots.raise_()

    def plot_results(self):
        mes = self.sim.Measured_Chlorine()
        selected_features = self.junctions_layer.selectedFeatures()
        sensor_index = []
        sensor_ids = []
        for i, feature in enumerate(selected_features):
            # Todo: Change for more plots
            if i == 4:
                break
            sensor_ids.append(feature['id'])
            sensor_index.append(self.node_id.index(feature['id']) + 1)

        # sensor_description = ['DMA_DP3', 'DMA_inlet', 'Tank_outlet', 'DWTP_outlet']
        sensor_description = sensor_ids
        selected_species = self.dockwidget.sim_multi_model_species.checkedItems()
        if selected_species:
            species_index = []
            for sen_id in selected_species:
                species_index.append(self.species_names_function.index(sen_id) + 1)
            canvas = self.sim.plot_data(mes, [self.results], sensor_index, species_index, selected_species, sensor_description, "",
                                        show_measured=False)
            self.create_dock_widget_with_plot(canvas)

    def showYesNoMessage(self, title, msg, yesMethod, noMethod, icon):
        msgBox = QMessageBox()
        if icon == 'Warning':
            msgBox.setIcon(QMessageBox.Warning)
        if icon == 'Info':
            msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle(title)
        msgBox.setText(msg)
        msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        # msgBox.setWindowFlags(Qt.CustomizeWindowHint | Qt.WindowStaysOnTopHint | Qt.WindowCloseButtonHint)
        buttonY = msgBox.button(QMessageBox.Yes)
        buttonY.setText('OK')
        buttonY.clicked.connect(yesMethod)
        buttonNo = msgBox.button(QMessageBox.No)
        buttonNo.clicked.connect(noMethod)
        buttonNo.setText('Cancel')
        msgBox.exec_()

    def populate_model_files(self, subfolder, extension, exclude_suffix, target_combobox):
        folder_path = os.path.join(self.plugin_dir, "data", subfolder)

        if not os.path.exists(folder_path):
            return

        files = [
            f for f in os.listdir(folder_path) if f.endswith(extension) and not f.endswith(exclude_suffix)
        ]

        target_combobox.clear()
        target_combobox.addItems(files)

    def ignore_hours(self):
        if self.dockwidget.hour_min_max.currentText() != 'hour':
            self.dockwidget.sim_hour.setEnabled(False)
        else:
            self.dockwidget.sim_hour.setEnabled(True)

    def show_hydraulic_info(self):
        """Displays a summary of the selected hydraulic model using getCounts() from epanet."""

        # Get selected filename from the dropdown
        selected_model = self.dockwidget.network_models.currentText()

        if not selected_model:
            self.show_message("Warning", "Please select a network model first.", button="OK", icon="Warning")
            return

        # Build full path to the selected .inp file
        model_path = os.path.join(self.plugin_dir, "data", "network_models", selected_model)

        if not os.path.exists(model_path):
            self.show_message("Warning", f"Selected network model file not found:\n{model_path}", button="OK",
                              icon="Warning")
            return

        # Load the model using epanet
        try:
            self.G = epanet(model_path)
            counts = self.G.getCounts()

            msg = (
                f"Hydraulic Model: {selected_model}\n\n"
                f"Nodes: {counts.Nodes}\n"
                f"  ├─ Junctions: {counts.Junctions}\n"
                f"  ├─ Reservoirs: {counts.Reservoirs}\n"
                f"  └─ Tanks: {counts.Tanks}\n\n"
                f"Links: {counts.Links}\n"
                f"  ├─ Pipes: {counts.Pipes}\n"
                f"  ├─ Pumps: {counts.Pumps}\n"
                f"  └─ Valves: {counts.Valves}\n\n"
                f"Patterns: {counts.Patterns}\n\n"
                f"Curves: {counts.Curves}\n\n"
                f"Controls:\n"
                f"  ├─ Simple: {counts.SimpleControls}\n"
                f"  └─ Rule-Based: {counts.RuleBasedControls}"
            )

            self.show_message("Hydraulic Info", msg, button="OK", icon="Info")

        except Exception as e:
            self.show_message("Error", f"Failed to load the network model:\n{e}", button="OK",
                              icon="Warning")

    def show_reaction_info(self):
        """Displays the content of the selected reaction model (.msx file) in a scrollable text dialog."""

        selected_model = self.dockwidget.reaction_models.currentText()

        if not selected_model:
            self.show_message("Warning", "Please select a reaction model.", button="OK", icon="Warning")
            return

        full_path = os.path.join(self.plugin_dir, "data", "reaction_models", selected_model)

        if not os.path.exists(full_path):
            self.show_message("Error", f"Selected reaction model file not found:\n{full_path}", button="OK",
                              icon="Warning")
            return

        try:
            with open(full_path, 'r', encoding='utf-8') as file:
                content = file.read()
        except Exception as e:
            self.show_message("Error", f"Failed to read file:\n{e}", button="OK", icon="Warning")
            return

        # Create and configure the dialog
        dialog = QDialog(self.dockwidget)
        dialog.setWindowTitle(f"Reaction Model: {selected_model}")
        dialog.setMinimumSize(600, 500)

        layout = QVBoxLayout(dialog)

        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setPlainText(content)
        layout.addWidget(text_edit)

        close_button = QPushButton("Close")
        close_button.clicked.connect(dialog.accept)
        layout.addWidget(close_button)

        dialog.exec_()

    def open_data_folder(self):
        folder_path = os.path.join(self.plugin_dir, "data")

        if not os.path.exists(folder_path):
            self.show_message("Error", f"The folder does not exist:\n{folder_path}", button="OK", icon="Warning")
            return

        try:
            if platform.system() == 'Windows':
                os.startfile(folder_path)
            elif platform.system() == 'Darwin':  # macOS
                subprocess.run(['open', folder_path])
            else:  # Linux and others
                subprocess.run(['xdg-open', folder_path])
        except Exception as e:
            self.show_message("Error", f"Failed to open folder:\n{e}", button="OK", icon="Warning")

    def set_default_parameter_value(self):
        selected_param = self.dockwidget.chemical_parameters.currentText()
        if hasattr(self, 'parameter_defaults') and selected_param in self.parameter_defaults:
            default_value = self.parameter_defaults[selected_param]
            self.dockwidget.chem_parameter_value.setValue(default_value)

    def update_scenario_buttons(self):
        """
        Enables 'export_scenario' and 'run_simulation' buttons only if scenario_table has rows.
        """
        has_rows = self.dockwidget.scenario_table.rowCount() > 0
        self.dockwidget.export_scenario.setEnabled(has_rows)
        self.dockwidget.run_simulation.setEnabled(has_rows)
        self.dockwidget.delete_action.setEnabled(has_rows)
        self.dockwidget.clear_scenario.setEnabled(has_rows)

    def update_plot_buttons(self):
        """
        Enables plot buttons only if at least one species is checked.
        """
        checked_items = self.dockwidget.sim_multi_model_species.checkedItems()
        enabled = bool(checked_items)

        self.dockwidget.plot_species_nodes.setEnabled(enabled)
        self.dockwidget.plot_species_locations.setEnabled(enabled)

    def exportMSXstatistics(self, input_path, output_path="summary_output.xlsx", nodeids=True, nodeindex=True):
        """
        Summarizes min, max, and average values for each node in an Excel file with a specific structure.

        Parameters:
            input_path (str): Path to the input Excel file.
            output_path (str): Path to save the output summary Excel file.
            nodeids (bool): Include node IDs (from column 1) in the summary.
            nodeindex (bool): Include node index (from column 0) in the summary.

            # Example usage:
            exportMSXstatistics("outexcel3.xlsx","summary_output1.xlsx", nodeids=True, nodeindex=False)  # Only node IDs
            exportMSXstatistics("outexcel3.xlsx", "summary_output2.xlsx",nodeids=False, nodeindex=True)  # Only node indices
            exportMSXstatistics("outexcel3.xlsx","summary_output3.xlsx", nodeids=True, nodeindex=True)   # Both
        """
        xls = pd.ExcelFile(input_path)
        output_data = {}

        for sheet in xls.sheet_names:
            df = xls.parse(sheet, header=None)

            data = df.iloc[1:].reset_index(drop=True)

            summary_rows = []

            for _, row in data.iterrows():
                index = int(row[0])
                node_id = str(row[1])
                values = pd.to_numeric(row[2:], errors='coerce').dropna()

                if values.empty:
                    continue

                summary = {
                    'Min': values.min(),
                    'Max': values.max(),
                    'Mean': values.mean()
                }

                if nodeids:
                    summary['NodeID'] = node_id
                if nodeindex:
                    summary['NodeIndex'] = index

                ordered_summary = {}
                if nodeids:
                    ordered_summary['NodeID'] = summary['NodeID']
                if nodeindex:
                    ordered_summary['NodeIndex'] = summary['NodeIndex']
                ordered_summary['Min'] = summary['Min']
                ordered_summary['Max'] = summary['Max']
                ordered_summary['Mean'] = summary['Mean']

                summary_rows.append(ordered_summary)

            output_data[sheet] = pd.DataFrame(summary_rows)

        with pd.ExcelWriter(output_path) as writer:
            for sheet_name, df in output_data.items():
                df.to_excel(writer, sheet_name=sheet_name+'_stats', index=False)

        # print(f"Summary saved to: {output_path}")

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING dbpSimulator"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget is None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = dbpSimulatorDockWidget()
                self.imported_excel_file = os.path.join(self.plugin_dir, 'data', 'ts_data', 'sensors_data.xlsx')
                self.dockwidget.excel_path.setText(self.imported_excel_file)

                self.populate_model_files(
                    subfolder="network_models",
                    extension=".inp",
                    exclude_suffix="_temp.inp",
                    target_combobox=self.dockwidget.network_models
                )

                self.populate_model_files(
                    subfolder="reaction_models",
                    extension=".msx",
                    exclude_suffix="_temp.msx",
                    target_combobox=self.dockwidget.reaction_models
                )

                self.dockwidget.import_node_injection.clicked.connect(lambda: self.on_node_button_clicked(self.dockwidget.node_selected_injection))
                self.dockwidget.import_node_initial_conc.clicked.connect(lambda: self.on_node_button_clicked(self.dockwidget.node_selected_initial_conc))
                self.dockwidget.loadexcel.clicked.connect(lambda: self.import_excel_file(lbl_browse))
                self.dockwidget.loadmodels.clicked.connect(self.load_models)
                self.dockwidget.insert_action.clicked.connect(self.update_scenario_list)
                self.dockwidget.delete_action.clicked.connect(self.scenario_delete)
                self.dockwidget.run_simulation.clicked.connect(self.run_message)
                self.dockwidget.plot_species_nodes.clicked.connect(self.plot_results)
                self.dockwidget.plot_species_locations.clicked.connect(self.plot_sensorlocations)
                self.dockwidget.clear_scenario.clicked.connect(self.clear_scenario_table)
                self.dockwidget.show_update_map.clicked.connect(self.show_update_map_call)
                self.dockwidget.export_scenario.clicked.connect(self.save_scenarios_to_csv)
                self.dockwidget.import_scenario.clicked.connect(self.load_scenarios_from_csv)
                self.dockwidget.info_hydraulic.clicked.connect(self.show_hydraulic_info)
                self.dockwidget.info_reaction.clicked.connect(self.show_reaction_info)
                self.dockwidget.data_manager.clicked.connect(self.open_data_folder)
                self.dockwidget.chemical_parameters.currentIndexChanged.connect(self.set_default_parameter_value)
                self.dockwidget.sim_multi_model_species.checkedItemsChanged.connect(self.update_plot_buttons)
                self.dockwidget.samplings_checkbox.setEnabled(False)

                self.dockwidget.info_hydraulic.setIcon(
                    QIcon(os.path.join(self.plugin_dir, 'images', 'icons8-info-50.png'))
                )
                self.dockwidget.info_reaction.setIcon(
                    QIcon(os.path.join(self.plugin_dir, 'images', 'icons8-info-50.png'))
                )

                self.dockwidget.hour_min_max.currentIndexChanged.connect(self.ignore_hours)
            else:
                self.dockwidget.loadexcel.setEnabled(False)
                self.dockwidget.insert_action.setEnabled(False)
                self.dockwidget.scenario_table.setEnabled(False)
                self.dockwidget.import_scenario.setEnabled(False)
                self.dockwidget.export_scenario.setEnabled(False)
                self.dockwidget.data_manager.setEnabled(False)
                # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)

            lbl_browse = self.dockwidget.excel_path

            self.dockwidget.show()
            self.layers_panel = self.iface.mainWindow().findChild(QDockWidget, "Layers")
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.layers_panel)
            # self.iface.mainWindow().menuBar().setVisible(False)
